## # 1.  Модульные тесты:

1)  Если входной JSON не валиден, тестируемый метод возвращает 400 с сообщением об ошибке;

2)  Если *card_holder* содержит более одного пробела, то тестируемый метод возвращает 400 с сообщением об ошибке;

3)  Если card_number содержит не 16 цифр, тестируемый метод возвращает 400 с сообщением об ошибке;

4)  Если cvv содержит не 3 цифры, тестируемый метод возвращает 400 с  сообщением об ошибке;

5)  Если *card_expiration* не соответствует шаблону «мм/гг», тестируемый метод возвращает 400 с сообщением об ошибке;

6)  Если *card_expiration* относится к прошедшей дате, тестируемый метод  возвращает 400 с сообщением об ошибке;

7)  Если длина *order_number* 0 или больше 16 символов, тестируемый метод возвращает 400 с сообщением об ошибке;

8)  Если *sum* не соответствует формату числа с разделителем в запятой, тестируемый метод возвращает 400 с сообщением об ошибке;

9)  Если *sum* меньше или равно 0, тестируемый метод возвращает 400 с сообщением об ошибке;

10) Если входной JSON валиден, *card_holder* валиден, *card_number* валиден, card_expiration валиден и не в прошлом, *order_number* валиден, *cvv* -- три цфиры, *sum* валидна и больше 0, тестируемый метод возвращает 200 с сообщением об успехе.


## # 2.  Интеграционные тесты:

### a.  Проверяем связку «фронт-бэк»:

1) Если *card_holder* содержит более одного пробела, то после получения ответа от бэка на фронте выделяется поле «Номер карты» красной рамкой;

2) Если *card_expiration* не соответствует шаблону «мм/гг», то после получения ответа от бэка на фронте выделяется поле «месяц/год окончания действия карты» красной рамкой;

3) Если *cvv* содержит не три цифры, то после получения ответа от бэка на фронте выделяется поле «*cvv*» красной рамкой;

4) Если *sum* не соответствует формату числа с разделителем в запятой, то после получения ответа от бэка на фронте выделяется поле «*sum*» красной рамкой;

5) Если *order_number* состоит из одного пробела, то после получения ответа от бэка на фронте выделяется поле «*order_number*» красной рамкой;

6) Если *card_holder* валиден, *card_number* валиден, card_expiration валиден и не в прошлом, *order_number* валиден, *cvv* -- три цфиры, *sum* валидна и больше 0, на фронте выводится сообщение «Заказ успешно оплачен!».

### b.  Проверяем связку «бэк-репозиторий»:

1)  Если *order_number* или *sum* невалидны, получаем исключение.

2)  Если *order_number* и *sum* валидны, получаем true.

3)  Если делается второй вызов с тем же *order_number* и *другой суммой*, получаем исключение.

### c.  Проверяем связку «бэк-сервис **A**»:

1)  На тестовом двойнике проверяем ответ сервиса с превышением таймаута     (к примеру, 60 с), в тесте с искусственной задержкой ответа от сервиса А, бэк возвращает сообщение об ошибке с кодом 400 с формулировкой «Нет ответа от платежного шлюза, попробуйте оплатить позднее».

2)  Если *card_holder* валиден, *card_number* валиден, но содержит заведомо неверный номер карты, *card_expiration* валиден и не в прошлом, *order_number* валиден, *cvv* -- три цфиры, *sum* валидна и больше 0, сервис **A** возвращает 403 с сообщением об ошибке.

3)  Если *card_holder* валиден, *card_number* валиден, *card_expiration* валиден и не в прошлом, *cvv* -- три цифры, *sum* равна 1 р валидна  и больше 0, сервис **A** возвращает 200 с сообщением об успехе. Если банк выдал данные тестовых карт, то используем одну из них для положительного теста.

## 3.  Системные тесты:

a.  Если *cvv* неверен, то после получения ответа от бэка на фронте выводится сообщение об ошибке «Не удалось списать данные с карты, проверьте реквизиты».

b.  Если данные карты верны, sum равна 1 р, то после получения ответа от бэка на фронте выводится сообщение об ошибке «Заказ успешно оплачен!». Также здесь уместно использовать тестовые данные карт, выданных платежным шлюзом.

c.  При эмуляции зависания бэка (большое время ответа), на фроне выдается сообщение об ошибке: «Нет ответа от платежного шлюза, попробуйте оплатить позднее»
