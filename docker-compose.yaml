# версия синтаксиса
version: '3'

# в этом блоке мы описываем контейнеры, которые будут запускаться
services:
  #контейнер с Nginx
  nginx:
    build:
      context: "./nginx/${APP_ENV}"
      dockerfile: Dockerfile
    image: "${ENAME}/nginx"
    container_name: "webserver_${ENAME}"
    depends_on:
      - php
    # проброс портов
    ports:
      - "80:80"
    volumes:
      - ./code:/code
    networks:
      - internal

  #Контейнер с PHP-FPM, назовём его app
  php:
    # Если нет секции build, то система будет искать образ в репозиториях
    build:
      context: "./fpm/${APP_ENV}"
      dockerfile: Dockerfile
    image: "${ENAME}/php" # имя будущего образа
    container_name: "php_${ENAME}" # имя контейнера после запуска
    depends_on:
      - db
    volumes:
      - ./code:/code
      - "./fpm/${APP_ENV}/xdebug.ini:/usr/local/etc/php/conf.d/xdebug.ini"
      - "./fpm/${APP_ENV}/php.ini:/usr/local/etc/php/conf.d/php.ini"
    environment:
      XDEBUG_CONFIG: "remote_host=${REMOTE_HOST} remote_enable=1 "
      PHP_IDE_CONFIG: "serverName=${SERVER_NAME}"
    # мы можем создать для контейнеров внутреннюю сеть
    networks:
      - internal

  db:
    image: postgres:13.3
    container_name: "db_${ENAME}"
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_USER: ${POSTGRES_USER}
      PGDATA: "/var/lib/postgresql/data/pgdata"
    ports:
      - "5432:5432"
      # You should definitely change the password in production
    volumes:
      - ./dbdata:/var/lib/postgresql/data
      - ./code/sql:/sql
    networks:
      - internal

  workspace:
    build:
      context: "./console/${APP_ENV}"
      dockerfile: Dockerfile
    container_name: "console_${ENAME}"
    image: "${ENAME}/php-cli"
    volumes:
      - ./code:/code
      - "./console/${APP_ENV}/xdebug.ini:/usr/local/etc/php/conf.d/xdebug.ini"
      - "./console/${APP_ENV}/php.ini:/usr/local/etc/php/conf.d/php.ini"
    depends_on:
      - db
    environment:
      XDEBUG_CONFIG: "remote_host=${REMOTE_HOST} remote_enable=1"
      PHP_IDE_CONFIG: "serverName=${SERVER_NAME}"
    networks:
      - internal

  nodejs:
    build:
      context: ./nodejs
      dockerfile: Dockerfile
    container_name: "nodejs_${ENAME}"
    image: "${ENAME}/nodejs"
    volumes:
      - ./code:/code
    networks:
      - internal

  memcached:
    image: 'bitnami/memcached:latest'
    container_name: memcached
    ports:
      - '11211:11211'
    networks:
      - internal

  redis:
    image: redis:6.2-alpine
    restart: always
    container_name: redis
    ports:
      - '6379:6379'
    command: redis-server --save 20 1 --loglevel warning --requirepass eYVX7EwVmmxKPCDmwMtyKVge8oLd2t81
    volumes:
      - redis:/data
    networks:
      - internal

  # Elasticsearch Docker Images: https://www.docker.elastic.co/
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.10.0
    container_name: elasticsearch
    environment:
      - "discovery.type=single-node"
      - "bootstrap.memory_lock=true"
      - "ES_JAVA_OPTS=-Xms1G -Xmx1G"
      - "xpack.security.enabled=false"
      - "http.cors.enabled=true"
      - "http.cors.allow-origin=*"

    ulimits:
      memlock:
        soft: -1
        hard: -1
      nofile:
        soft: 65536
        hard: 65536
    cap_add:
      - IPC_LOCK
    volumes:
      - elasticsearch-data:/usr/share/elasticsearch/data
    ports:
      - 9200:9200
      - 9300:9300

    networks:
      - internal

  kibana:
    container_name: kibana
    image: docker.elastic.co/kibana/kibana:7.4.0
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
    ports:
      - 5601:5601
    depends_on:
      - elasticsearch
    networks:
      - internal

volumes:
  redis:
    driver: local
  db:
    driver: local
  elasticsearch-data:
    driver: local

#Docker Networks
networks:
  internal:
    driver: bridge
    ipam:
      driver: default
      config:
        - subnet: 192.168.220.0/28